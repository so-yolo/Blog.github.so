<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mmap_overlapping_chunks</title>
    <link href="/mmap-overlapping-chunks/"/>
    <url>/mmap-overlapping-chunks/</url>
    
    <content type="html"><![CDATA[<h1 id="mmap-overlapping-chunks"><a href="#mmap-overlapping-chunks" class="headerlink" title="mmap_overlapping_chunks"></a>mmap_overlapping_chunks</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>请内存的系统调用有brk和mmap两种：</p><ol><li>brk是将数据段(.data)的最高地址上方的指针_edata往高地址推。（并非修改数据段的最高地址上限）</li><li>mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</li></ol><p><img src="/./mmap-overlapping-chunks/image-20250604232545368.png" alt="image-20250604232545368"></p><p>在 glibc 中，当分配一个巨大的内存块时，它将不会采用常规的方式从现有的 heap 段中进行分配，而是会调用 <code>sysmalloc()</code> 函数并最终通过系统调用 <code>mmap()</code> 完成内存的分配。此次分配会返回给用户一块虚拟内存。<br><img src="/./mmap-overlapping-chunks/image-20250604232443767.png" alt="image-20250604232443767"></p><p>那么多大的内存块会触发 <code>mmap()</code> 系统调用呢？</p><blockquote><p>当申请内存时，系统调用 mmap 的条件通常与内存分配的最小单位和系统设定的阈值有关。</p><p><strong>默认阈值：</strong>在大多数系统中，mmap 的阈值（mmap_threshold）默认为 128KB（32位）（131072字节）。当申请的内存大小超过此阈值时，系统会优先使用 mmap 分配内存，以减少碎片化或 1MB（64位） 时，系统会调用 mmap。<br><strong>小规模阈值：</strong>某些实现（如glibc）可能将 <code>mmap_threshold</code> 设置为 4096字节（4KB），此时当申请超过4KB时，系统会尝试使用 <code>mmap</code>，但需结合页对齐要求<br><strong>强制调用：</strong>若 brk 失败，malloc 会强制使用 mmap 分配1MB内存，即使实际需求小于1MB</p></blockquote><p>小规模阈值中的mmap_threshold 字段决定在malloc_par 结构体中，参考下图，<strong>这个值会被设置为 0x20000</strong><br><img src="/./mmap-overlapping-chunks/image-20250605015143341.png" alt="image-20250605015143341"></p><p><strong>有两点需要注意哦:</strong></p><p><strong>动态调整：</strong>当分配的内存块大小超过当前阈值时，系统会动态调整阈值。例如，若释放的mmap块大于当前阈值，阈值会被更新为新值的上限（如mmap_threshold的上限为4<em>1024</em>1024字节）</p><p><strong>关于对齐</strong>:对齐：普通的 chunk 是按照 0x10 对齐的，例如 malloc() 一个容纳 0x30 字节空间的内存，就会分配一个 0x40 大小的 chunk，虽然分配 0x38 字节就够了，因为下一个 chunk 的 prev_size 字段可以存 0x8 字节的数据。但是为了对齐，最终会分配一个 0x40 大小的 chunk。对于 mmap() 申请的内存则是按照页（0x1000 &#x2F; 4096 &#x2F; 4KB）对齐的。例如mmap() 一个可以容纳 0x100000 字节的内存，虽然 0x100010 空间就够，但是要按照页对齐，所以最终会分配一个 0x101000 大小的空间</p><p><img src="/./mmap-overlapping-chunks/mmap_overlapping_chunks_pre_2.png" alt="img"></p><h2 id="how2heap-2-23的源码分析"><a href="#how2heap-2-23的源码分析" class="headerlink" title="how2heap-2.23的源码分析"></a>how2heap-2.23的源码分析</h2><p>我把下面展示 的源码中的注释和print的东西删掉了，为了直观的理解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Technique should work on all versions of GLibC</span><br><span class="hljs-comment">Compile: `gcc mmap_overlapping_chunks.c -o mmap_overlapping_chunks -g`</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">POC written by POC written by Maxwell Dulin (Strikeout) </span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><br><span class="hljs-type">int</span>* ptr1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <br><span class="hljs-type">long</span> <span class="hljs-type">long</span>* top_ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100000</span>);<br><span class="hljs-type">long</span> <span class="hljs-type">long</span>* mmap_chunk_2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100000</span>);<br><span class="hljs-type">long</span> <span class="hljs-type">long</span>* mmap_chunk_3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100000</span>);<br><br>mmap_chunk_3[<span class="hljs-number">-1</span>] = (<span class="hljs-number">0xFFFFFFFFFD</span> &amp; mmap_chunk_3[<span class="hljs-number">-1</span>]) + (<span class="hljs-number">0xFFFFFFFFFD</span> &amp; mmap_chunk_2[<span class="hljs-number">-1</span>]) | <span class="hljs-number">2</span>;<br><br><span class="hljs-built_in">free</span>(mmap_chunk_3); <br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span>* overlapping_chunk = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x300000</span>);<br><br><span class="hljs-type">int</span> distance = mmap_chunk_2 - overlapping_chunk;<br>overlapping_chunk[distance] = <span class="hljs-number">0x1122334455667788</span>;<br>assert(mmap_chunk_2[<span class="hljs-number">0</span>] == overlapping_chunk[distance]);<br><br>_exit(<span class="hljs-number">0</span>); <span class="hljs-comment">// exit early just in case we corrupted some libraries</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc mmap_overlapping_chunks.c -o mmap_overlapping_chunks -g<br></code></pre></td></tr></table></figure><p>我们可以看到在malloc(0x10）之前是没有分配出heap的段的<br><img src="/./mmap-overlapping-chunks/image-20250606150455292.png" alt="image-20250606150455292"></p><p>当mmap(0x100000)过后，我们可以看到vmmap中的蓝色的框，里面的是分配的m1的地址范围，我们再看上面print打印出来的地址是m1地址+0x10的地址，显然是相当于bins中chunk的fd指针的位置，这才是真正存储数据地址的开始的地方。同时我们就可以看到m1的地址是在libc.so的映射的上面的（地址空间的）<br><img src="/./mmap-overlapping-chunks/image-20250606150727566.png" alt="image-20250606150727566"></p><p><strong>m2的地址在libc的下面的（地址空间的下面），为什么不在一起呢？</strong><br>    两块0x100000  内存块分别位于 libc.so .6  上方和下方，是由于 文件映射区的空间碎片化  和 内核动态分配策略  导致的。ASLR  随机化libc 的基址后，文件映射区 的空闲地址可能分散在其两侧，内核会优先利用这些碎片空间分配mmap 内存，从而出现 不对称布局。</p><p><img src="/./mmap-overlapping-chunks/image-20250606150838410.png" alt="image-20250606150838410"></p><p>这里是m2与m3的空间总和在一块了，并且m3的地址是在m2的地址的下面的<br><img src="/./mmap-overlapping-chunks/image-20250606151005791.png" alt="image-20250606151005791"></p><p>这里我们查看一下m3的地址情况，发现size的大小如下。<br><img src="/./mmap-overlapping-chunks/image-20250606214921963.png" alt="image-20250606214921963"></p><h2 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h2><p>​<strong>下面运行到修改m3 size的地方的时候内核崩掉了，因为mmap申请出来的地址，不可以随意修改，会导致崩溃的。</strong><br><strong>因此我就引用其他editor的截图说明了。</strong></p><hr><p>接下来的 overlapping 是常规的方法，更改 <em>m3</em> 的 size 段为 <em>m2</em> 和 <em>m3</em> 的大小之和。</p><p><img src="/./mmap-overlapping-chunks/mmap-m2-size.png" alt="img"></p><p><img src="/./mmap-overlapping-chunks/mmap-m2-size2.png" alt="img"></p><p>这样我们 free 掉 <em>m3</em> ，就会把 <em>m2</em>、<em>m3</em> 的整体内存部分归还给系统，我们此时查看 <code>mp_.mmap_threshold</code> 就变成了我们伪造的 chunk <em>m2</em> 的大小<br><img src="/./mmap-overlapping-chunks/mmap_mp_mmap_threshold.png" alt="img"></p><p>我们再此申请一个堆块，需要注意，这时申请的堆块大小需要大于 0x202000 ，不然会分配到 heap 块去。</p><p><a href="https://shmodifier.github.io/img/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%B8%80/mmap-heap-m4.png"><img src="/./mmap-overlapping-chunks/mmap-heap-m4.png" alt="img"></a></p><p>​这个技术可以进一步利用，我们可以覆盖 mmap 映射段的内存，这块内存中同时也保存着 libc.so 文件的映射。free 掉这块 overlap 后的内存的同时也会清空这块内存的内容，那么就可以取消 libc 映射后通过重写符号表（symbol table）来劫持其他的函数地址到我们想要的system函数地址。</p><p>参考文献：<a href="https://shmodifier.github.io/2024/03/05/how2heap%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%AD%A6%E4%B9%A0%E5%A0%86%E5%88%A9%E7%94%A8-%E4%BA%8C/#mmap-overlapping-chunks">how2heap深入浅出学习堆利用(二) - Modifier</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>how2heap-2.23</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOT-Protocol-HTTP</title>
    <link href="/IOT-Protocol-HTTP/"/>
    <url>/IOT-Protocol-HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="IOT协议之HTTP"><a href="#IOT协议之HTTP" class="headerlink" title="IOT协议之HTTP"></a>IOT协议之HTTP</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>​http协议作为现在互联网的标准型协议，因为其协议的资源要求比较高，其实用在iot这一块的占比是比较小的，不像前几个协议使用的这么广，但是我看HTTP&#x2F;2.0版本还有HTTP&#x2F;3.0的好像做了改动以适用于iot的领域，同时顺便学习一下HTTPS，正好全面的做个学习记录。</p></blockquote><h2 id="概图"><a href="#概图" class="headerlink" title="概图"></a>概图</h2><p><img src="/./IOT-Protocol-HTTP/image-20250602150926872.png" alt="image-20250602150926872"></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><blockquote><p>​HTTP（HyperText Transfer Protocol）是万维网（WWW）的核心协议，由蒂姆·伯纳斯-李（Tim Berners-Lee）提出，最初用于在分布式系统中传输超文本信息。它基于TCP&#x2F;IP协议，通常使用TCP 80端口，通过可靠的TCP连接实现数据传输。<br>​HTTP协议的请求&#x2F;响应模型决定了客户端主动发起请求，服务器被动响应，例如用户通过浏览器访问网页时，浏览器会发送HTTP请求，服务器返回对应的HTML内容HTTP 是 应用层协议，当你上网浏览网页的时候，浏览器和 Web 服务器之间就会通过 HTTP 在 Internet 上进行数据的发送和接收。<br>​HTTP 是一个基于请求&#x2F;响应模式的、无状态的协议。</p></blockquote><p><strong>核心特点</strong></p><ul><li>无状态性：HTTP协议本身不维护会话状态，每次请求独立处理。这意味着服务器无法记住客户端的先前行为，但可通过Cookie或Session技术实现状态管理。例如，用户登录后，服务器会生成一个Session ID并存储在Cookie中，后续请求需携带该ID以维持会话。</li><li>无连接性：每次请求仅处理一个任务，服务器完成响应后立即断开连接。这种方式简化了协议设计，但可能影响性能。HTTP&#x2F;1.1通过“持久连接”（Keep-Alive）机制允许复用TCP连接，减少建立和关闭连接的开销。</li><li>简单快速：协议语法简洁，仅需传输请求方法（如GET、POST）、资源路径和协议版本，无需复杂参数。例如，GET请求仅需在URL中附加参数，而POST请求需在请求体中提交数据。</li><li>灵活可扩展：支持多种请求方法（GET、POST、PUT、DELETE等）和媒体类型（如text&#x2F;html、image&#x2F;jpeg），允许传输任意类型的数据对象。此外，HTTP通过扩展机制（如Content-Type头）适应不同场景。</li></ul><p><strong>客户端请求流程</strong></p><p><img src="/./IOT-Protocol-HTTP/image-20250602151051310.png" alt="image-20250602151051310"></p><h2 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h2><p>​HTTP 报文是面向文本的，报文中的每个字段都是一些 ASCII 码串，各个字段的长度是不确定的。HTTP 有两类报文：请求报文 和 响应报文。HTTP 请求&#x2F;响应报文由以下内容组成:</p><ul><li>请求行&#x2F;状态行</li><li>请求头&#x2F;响应头</li><li>空行</li><li>请求体&#x2F;响应体</li></ul><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>HTTP 的请求报文分为三个部分：</p><ul><li>请求行<ul><li>请求方法（GET &#x2F; POST &#x2F; DELETE &#x2F; PUT &#x2F; HEAD）</li><li>请求资源的 URI 路径</li><li>HTTP 协议版本</li></ul></li><li>请求头（首部行）<ul><li>Content-Type</li></ul></li><li>空行</li><li>请求体（实体主体）</li></ul><p><img src="/./IOT-Protocol-HTTP/image-20250602151924416.png" alt="image-20250602151924416"></p><p><strong>例如</strong>：</p><p><img src="/./IOT-Protocol-HTTP/image-20250602152636402.png" alt="image-20250602152636402"></p><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>在此之前我先区分一下，请求体，请求头，请求行的区别：</p><p><strong>层级结构</strong>：</p><ul><li><p>请求行 → 请求头 → 请求体（空行分隔）</p></li><li><p>请求头和请求体共同构成请求的“主体”部分，而请求行是报文的“标题”</p><p><img src="/./IOT-Protocol-HTTP/image-20250602173239065.png" alt="image-20250602173239065"><img src="/./IOT-Protocol-HTTP/image-20250602173004662.png" alt="image-20250602173004662"></p></li></ul><p><strong>请求行</strong></p><ul><li>请求方法</li><li>请求地址 URL</li><li>HTTP 协议版本</li></ul><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>HTTP&#x2F;1.1 协议中共定义了八种方法，以不同的方式操作指定的资源。</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>GET</td><td>向指定的资源发出 <strong>显示</strong> 请求，使用 GET 方法应该只用在 <strong>读取数据</strong> 上，而不应该用于产生 <strong>副作用</strong> 的操作中。</td></tr><tr><td>POST</td><td>指定资源 <strong>提交数据</strong>，请求服务器进行处理（例如提交表单或者上传文件）。<strong>数据被包含在请求文本中</strong>。这个请求可能会创建新的资源或者修改现有资源，或两者皆有。</td></tr><tr><td>PUT</td><td>向指定资源位置上传其 <strong>最新内容</strong>。</td></tr><tr><td>DELETE</td><td>请求服务器删除 Request-URI 所标识的资源。</td></tr><tr><td>OPTIONS</td><td>使服务器传回该 <strong>资源支持的所有 HTTP 请求方法</strong>。用 <code>*</code> 来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。</td></tr><tr><td>HEAD</td><td>与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将 <strong>不传回资源的本文部分</strong>，它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中 <code>关于该资源的信息</code>（原信息或称元数据）。</td></tr><tr><td>TRACE</td><td>显示服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td>CONNECT</td><td>HTTP&#x2F;1.1 中预留给能够将连接改为通道方式的代理服务器。通常用于 SSL 加密服务器的链接（经由非加密的 HTTP 代理服务器）。</td></tr></tbody></table><p><strong>GET 与 POST</strong><br>HTTP 协议从未规定 GET&#x2F;POST 的请求长度限制是多少。对 GET 请求参数的限制是来源与浏览器或 Web 服务器，浏览器或 Web 服务器限制了 URL 的长度。</p><p>为了明确这个概念，我们必须再次强调下面几点：</p><ul><li>HTTP 协议 未规定 GET 和 POST 的长度限制</li><li>GET 的最大长度显示是因为 浏览器和 Web 服务器限制了 URI 的长度</li><li>不同的浏览器和 Web 服务器，限制的最大长度不一样</li><li>要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</li></ul><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>请求头中的信息有和缓存相关的头（Cache-Control，If-Modified-Since）、客户端身份信息（User-Agent）等等。<br>请求头的格式为：键: 值，注意 冒号后面有一个空格。</p><p><strong>实例</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>21429<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>api.github.com<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>https://github.com<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>https://github.com/<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36<br></code></pre></td></tr></table></figure><p><strong>常见的请求 Header</strong></p><table><thead><tr><th>请求头</th><th>说明</th></tr></thead><tbody><tr><td>Accept</td><td>表示浏览器接受的数据类型</td></tr><tr><td>Accept-Encoding</td><td>表示浏览器接受的数据压缩格式</td></tr><tr><td>Host</td><td>表示当前请求访问的目标地址</td></tr><tr><td>Authorization</td><td>表示用户身份认证信息</td></tr><tr><td>User-Agent</td><td>表示浏览器类型</td></tr><tr><td>If-Modified-Since</td><td>表示当前请求资源最近一次更新时间</td></tr><tr><td>If-None-Match</td><td>表示当前请求资源最近一次标识的 ETag 值</td></tr><tr><td>Cookie</td><td>表示浏览器保存的 Cookie 信息</td></tr><tr><td>Referer</td><td>表示标识请求引用自哪个地址</td></tr></tbody></table><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p>请求体是 POST 请求方式中的请求参数，以 <code>key = value</code> 形式进行存储，多个请求参数之间用 <code>&amp;</code> 连接，如果请求当中请求体，那么在请求头当中的 Content-Length 属性记录的就是该请求体的长度。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">hysj.jsp</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>search.cnipr.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows;U;Windows NT 6.9;zh-CN;rv:1.9.1.13)Gecko/20100914 Firefox/3.5.13 (.NET CLR 3.5.30729)<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html, application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-cn,zh;q=0.5<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip,deflate<br><span class="hljs-attribute">Accept-Charst</span><span class="hljs-punctuation">: </span>GN2312,utf-8;q=0.7,*;q=0.7<br><span class="hljs-attribute">Keep-Alive</span><span class="hljs-punctuation">: </span>300<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://search.cnipr.com/cnipr/zljs/hyjs-biaodan-y.jsp<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>405<br><br><span class="language-apache"><span class="hljs-attribute">pageNo</span>=<span class="hljs-number">0</span>&amp;pageSize=<span class="hljs-number">10</span>&amp;orderNum=<span class="hljs-number">306735659327926273</span>&amp;customerMobile=<span class="hljs-number">15626000000</span>&amp;startTime=<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">01</span>%<span class="hljs-number">2000</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>&amp;endTime=<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">25</span>%<span class="hljs-number">2014</span>:<span class="hljs-number">54</span>:<span class="hljs-number">20</span>&amp;status=SUCCESS&amp;source=WECHAT_SHOPPING&amp;canteenId=<span class="hljs-number">104</span>&amp;refundStatus=REFUNDED&amp;startPayTime=<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">01</span>%<span class="hljs-number">2000</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>&amp;endPayTime=<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">25</span>%<span class="hljs-number">2014</span>:<span class="hljs-number">54</span>:<span class="hljs-number">47</span></span><br></code></pre></td></tr></table></figure><hr><h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><p>​HTTP 响应的格式上除状态行（第一行）与请求报文的请求行不一样之外，其他的就格式而言是一样的，但排除状态行和请求行的区别，从 Header 上还是可以区分出 HTTP 请求和 HTTP 响应的区别的，怎么区别就要看前面的 Header。</p><p>HTTP 的响应报文分为三个部分：</p><ul><li>状态行<ul><li>HTTP 协议版本</li><li>状态码</li><li>短语</li></ul></li><li>响应头</li><li>空行</li><li>响应体</li></ul><p><img src="/./IOT-Protocol-HTTP/image-20250602152404797.png" alt="image-20250602152404797"></p><p><strong>例如</strong></p><p><img src="/./IOT-Protocol-HTTP/image-20250602152725056.png" alt="image-20250602152725056"></p><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>状态码用以表示网页服务器超文本传输协议响应状态的三位数字码</p><table><thead><tr><th>状态码</th><th>对应信息</th></tr></thead><tbody><tr><td>1XX</td><td>提示信息，表示请求已接收，继续处理</td></tr><tr><td>2XX</td><td>用于表示请求已被成功接收、理解、接收</td></tr><tr><td>3XX</td><td>用于表示资源（网页等）被永久转移到其它 URL，也就是所谓的重定向</td></tr><tr><td>4XX</td><td>客户端错误—请求有语法错误或者请求无法实现</td></tr><tr><td>5XX</td><td>服务器端错误—服务器未能实现合法的请求</td></tr></tbody></table><p><strong>1XX 信息</strong></p><ul><li>100 Continue : 表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><p><strong>2XX 成功</strong></p><ul><li><p>200 OK</p></li><li><p>204 No Content : 请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p></li><li><p>206 Partial Content : 表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</p></li></ul><p><strong>3XX 重定向</strong></p><ul><li><p>301 Moved Permanently : 永久性重定向</p></li><li><p>302 Found : 临时性重定向</p></li><li><p>303 See Other : 和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p></li><li><p>注: 虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</p></li><li><p>304 Not Modified : 如果请求报文首部包含一些条件，例如: If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p></li><li><p>307 Temporary Redirect : 临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p></li></ul><p><strong>4XX 客户端错误</strong></p><ul><li><p>400 Bad Request : 请求报文中存在语法错误。</p></li><li><p>401 Unauthorized : 该状态码表示发送的请求需要有认证信息(BASIC 认证、DIGEST 认证)。如果之前已进行过一次请求，则表示用户认证失败。</p></li><li><p>403 Forbidden : 请求被拒绝。</p></li><li><p>404 Not Found</p></li></ul><p><strong>5XX 服务器错误</strong></p><ul><li>500 Internal Server Error : 服务器正在执行请求时发生错误。</li><li>503 Service Unavailable : 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>响应头同样可用于传递一些附加信息。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.0</span> <span class="hljs-number">200</span> ok<br><span class="hljs-attribute">content-type</span><span class="hljs-punctuation">: </span>application/javascript;charset=utf-8<br><span class="hljs-attribute">date</span><span class="hljs-punctuation">: </span>Tue, 07 Mar 2017 03:06:14 GMT<br><span class="hljs-attribute">sever</span><span class="hljs-punctuation">: </span>Domain Reliability Searver<br><span class="hljs-attribute">content-length</span><span class="hljs-punctuation">: </span>0<br><span class="hljs-attribute">x-xss-protection</span><span class="hljs-punctuation">: </span>1, mode=bloack<br><span class="hljs-attribute">x-frame-options</span><span class="hljs-punctuation">: </span>SAMEORIGIN<br><span class="hljs-attribute">alt-svc</span><span class="hljs-punctuation">: </span>quic=&quot;:443&quot;;ma=2592000;v=&quot;36,35,34&quot;<br></code></pre></td></tr></table></figure><p>常见的响应头 <strong>Header</strong></p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>Date</td><td>表示当前相应资源发送的服务器日期和时间</td></tr><tr><td>Last-Modified</td><td>表示当前响应资源最后被修改的服务器时间</td></tr><tr><td>Transfer-Encoding</td><td>表示当前响应资源传输实体的编码格式</td></tr><tr><td>Set-Cookie</td><td>表示设置 Cookie 信息</td></tr><tr><td>Location</td><td>在重定向中或者创建新资源时使用</td></tr><tr><td>Server</td><td>表示服务器名称</td></tr></tbody></table><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>​响应体也就是网页的正文内容，一般在响应头中会用 Content-Length 来明确响应体的长度，便于浏览器接收，对于大数据量的正文信息，也会使用 chunked 的编码方式。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>超文本传输安全协议</strong>（Hyper Text Transfer Protocol over Secure Socket Layer，HTTPS），是一种通过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 <strong>SSL &#x2F; TLS</strong> 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p><p>HTTP 有以下安全性问题:</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>​HTTPs 并不是新协议，而是让 HTTP 先和 SSL(Secure Sockets Layer)通信，再由 SSL 和 TCP 通信，也就是说 HTTPs 使用了隧道进行通信。<br>通过使用 SSL，HTTPs 具有了加密(防窃听)、认证(防伪装)和完整性保护(防篡改)。</p><p><img src="/./IOT-Protocol-HTTP/image-20250602175406750.png" alt="image-20250602175406750"></p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><h4 id="1-对称密钥加密"><a href="#1-对称密钥加密" class="headerlink" title="1. 对称密钥加密"></a>1. 对称密钥加密</h4><p>对称密钥加密(Symmetric-Key Encryption)，加密和解密使用同一密钥。</p><ul><li>优点: 运算速度快；</li><li>缺点: 无法安全地将密钥传输给通信方。</li></ul><p><img src="/./IOT-Protocol-HTTP/image-20250602191538069.png" alt="image-20250602191538069"></p><p>2.非对称密钥加密<br>非对称密钥加密，又称公开密钥加密(Public-Key Encryption)，加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><p>优点: 可以更安全地将公开密钥传输给通信发送方；<br>缺点: 运算速度慢。</p><p><img src="/./IOT-Protocol-HTTP/image-20250602191619054.png" alt="image-20250602191619054"></p><h4 id="3-HTTPs-采用的加密方式"><a href="#3-HTTPs-采用的加密方式" class="headerlink" title="3. HTTPs 采用的加密方式"></a>3. HTTPs 采用的加密方式</h4><p>HTTPs 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。(下图中的 Session Key 就是对称密钥)</p><p><img src="/./IOT-Protocol-HTTP/How-HTTPS-Works.png" alt="img"></p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>通过使用 证书 来对通信方进行认证。</p><p>数字证书认证机构(CA，Certificate Authority)是客户端与服务器双方都可信赖的第三方机构。</p><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPs 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><p>通信开始时，客户端需要使用服务器的公开密钥将自己的私有密钥传输给服务器，之后再进行对称密钥加密。</p><p><img src="/./IOT-Protocol-HTTP/2017-06-11-ca.png" alt="img"></p><h3 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h3><p>SSL 提供报文摘要功能来进行完整性保护。</p><p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p><p>HTTPs 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><p>###HTTPs 的缺点<br>因为需要进行加密解密等过程，因此速度会更慢；<br>需要支付证书授权的高额费用。</p><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h2><h3 id="HTTP-1-x-缺陷"><a href="#HTTP-1-x-缺陷" class="headerlink" title="HTTP&#x2F;1.x 缺陷"></a>HTTP&#x2F;1.x 缺陷</h3><p>HTTP&#x2F;1.x 实现简单是以牺牲性能为代价的:</p><p>客户端需要使用多个连接才能实现并发和缩短延迟；<br>不会压缩请求和响应首部，从而导致不必要的网络流量；<br>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</p><p>###二进制分帧层</p><p>HTTP&#x2F;2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的</p><p><img src="/./IOT-Protocol-HTTP/86e6a91d-a285-447a-9345-c5484b8d0c47.png" alt="img"></p><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流(Stream)。</p><ul><li>一个数据流都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li><li>消息(Message)是与逻辑请求或响应消息对应的完整的一系列帧。</li><li>帧(Fram)是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><p><img src="/./IOT-Protocol-HTTP/af198da1-2480-4043-b07f-a3b91a88b815.png" alt="img"></p><h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>HTTP&#x2F;2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p><p><img src="/./IOT-Protocol-HTTP/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png" alt="img"></p><h3 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h3><p>HTTP&#x2F;1.1 的首部带有大量信息，而且每次都要重复发送。</p><p>HTTP&#x2F;2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p><p>不仅如此，HTTP&#x2F;2.0 也使用 Huffman 编码对首部字段进行压缩。</p><p><img src="/./IOT-Protocol-HTTP/_u4E0B_u8F7D.png" alt="img"></p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>多路复用（MultiPlexing）：通过该功能，在一条连接上，您的浏览器可以同时发起无数个请求，并且响应可以同时响应。另外，多路复用中支持了流的优先级（Stream dependencies）设置，允许客户端告知服务器最优资源，可以优先传输。</p><p>当我们打开网站时，浏览器会对每个网页并发的连接进行限制，一般浏览器的 HTTP 请求并发数限制在 6-8 个。但实际上，绝大部分网站首页所需要的资源个数远大于这个限制。所以为了不让资源在下载阶段就被阻塞住，我们往往会把一些静态资源分散到 CDN 或其他服务器上，从而通过多域名的方式突破浏览器对并发连接数的限制，从而使得网站能同时下载尽可能多的资源。</p><p>但建立更多的连接也意味更多的开销。每个 HTTP 请求都对应建立 TCP 连接，也许有些资源体积只有几 kb，这些情况下建立连接本身的开销就变得更客观，很可能三次握手的实践比传输时间还长</p><p>在 HTTP&#x2F;2 中，有了二进制分帧之后，HTTP&#x2F;2 不再依赖 TCP 链接去实现多流并行，而是通过 流 支持多路复用。</p><p>将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP&#x2F;2 最重要的一项增强。事实上，这个机制会在整个网络技术栈中引发一系列连锁反应，从而带来巨大的性能提升，让我们可以：</p><p>并行交错地发送多个请求&#x2F;响应，请求&#x2F;响应之间互不影响<br>不必再为绕过 HTTP&#x2F;1.x 限制而做很多工作（请参阅 针对 HTTP&#x2F;1.x 进行优化，例如级联文件、Image Sprites 和域名分片<br>消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间<br>HTTP&#x2F;2 中的新二进制分帧层解决了 HTTP&#x2F;1.x 中存在的 队头阻塞 问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。</p><h2 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP&#x2F;3.0"></a>HTTP&#x2F;3.0</h2><p><strong>HTTP 发展历史</strong></p><ul><li>HTTP&#x2F;0.9 - 1991 单行协议：只支持 GET 方法；没有首部；只能获取纯文本</li><li>HTTP&#x2F;1.0 - 1996 搭建协议框架：增加了首部、状态码、权限、缓存、长连接（默认短连接）等规范</li><li>HTTP&#x2F;1.1 - 1997 默认长连接；缓存字段扩展；强制客户端提供 Host 首部；管线化</li><li>SPDY - 2012 强制压缩、多路复用、Pipeling、双向通信、优先级调用</li><li>HTTP&#x2F;2 - 2015 头部压缩、多路复用、Pipelining、Server push（解决 HTTP 队首阻塞）</li><li>HTTP&#x2F;3 - 2018 快速握手、可靠传输、有序交付（解决 TCP 队首阻塞）</li></ul><table><thead><tr><th>应用层</th><th>传输层</th><th>网络层</th></tr></thead><tbody><tr><td>HTTP</td><td>TCP</td><td>IP</td></tr><tr><td>HTTP&#x2F;2 + TLS&#x2F;1.2+</td><td>TCP</td><td>IP</td></tr><tr><td>HTTP&#x2F;3 + TLS&#x2F;1.3</td><td>QUIC（UDP）</td><td>IP</td></tr></tbody></table><h3 id="旧版本问题"><a href="#旧版本问题" class="headerlink" title="旧版本问题"></a>旧版本问题</h3><p>虽然 HTTP&#x2F;2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，主要是底层支撑的 TCP 协议造成的。HTTP&#x2F;2 的缺点主要有以下两点：</p><ul><li><strong>建立连接的延时：</strong>HTTP&#x2F;2 使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程</li><li><strong>队头阻塞并没有彻底解决：</strong>在 HTTP&#x2F;2 中，多个请求是跑在一个 TCP 管道中的。但当出现了丢包时，HTTP&#x2F;2 的表现反倒不如 HTTP&#x2F;1 了。因为 TCP 为了保证可靠传输，有个 丢包重传 机制，丢失的包必须要等待重新传输确认，HTTP&#x2F;2 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP 连接中的所有请求。而对于 HTTP&#x2F;1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据</li></ul><h3 id="HTTP3-简介"><a href="#HTTP3-简介" class="headerlink" title="HTTP3 简介"></a>HTTP3 简介</h3><p>Google 在推 SPDY 的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的“QUIC”协议，让 HTTP 跑在 QUIC 上而不是 TCP 上。 而这个“HTTP over QUIC”就是 HTTP 协议的下一个大版本，HTTP&#x2F;3。</p><p><img src="/./IOT-Protocol-HTTP/quic.84aa970d.png" alt="QUIC 协议"></p><p>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个 QUIC 新功能。不过 HTTP&#x2F;3 目前还处于草案阶段，正式发布前可能会有变动，所以本文尽量不涉及那些不稳定的细节。</p><h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><h4 id="零-RTT-建立连接"><a href="#零-RTT-建立连接" class="headerlink" title="零 RTT 建立连接"></a>零 RTT 建立连接</h4><p><img src="/./IOT-Protocol-HTTP/image-20250602200307883.png" alt="image-20250602200307883"></p><p>HTTP&#x2F;2 的连接需要 3 RTT，如果考虑会话复用，即把第一次握手算出来的对称密钥缓存起来，那么也需要 2 RTT，更进一步的，如果 TLS 升级到 1.3，那么 HTTP&#x2F;2 连接需要 2 RTT，考虑会话复用则需要 1 RTT。</p><p>有人会说 HTTP&#x2F;2 不一定需要 HTTPS，握手过程还可以简化。这没毛病，HTTP&#x2F;2 的标准的确不需要基于 HTTPS，但实际上所有浏览器的实现都要求 HTTP&#x2F;2 必须基于 HTTPS，所以 HTTP&#x2F;2 的加密连接必不可少。</p><p>而 HTTP&#x2F;3 首次连接只需要 1 RTT，后面的连接更是只需 0 RTT，意味着客户端发给服务端的第一个包就带有请求数据，这一点 HTTP&#x2F;2 难以望其项背。那这背后是什么原理呢？我们具体看下 QUIC 的连接过程。</p><p>首次连接时，客户端发送 Inchoate Client Hello 给服务端，用于请求连接；<br>服务端生成 g、p、a，根据 g、p 和 a 算出 A，然后将 g、p、A 放到 Server Config 中再发送 Rejection 消息给客户端；<br>客户端接收到 g、p、A 后，自己再生成 b，根据 g、p、b 算出 B，根据 A、p、b 算出初始密钥 K。B 和 K 算好后，客户端会用 K 加密 HTTP 数据，连同 B 一起发送给服务端；<br>服务端接收到 B 后，根据 a、p、B 生成与客户端同样的密钥，再用这密钥解密收到的 HTTP 数据。为了进一步的安全（前向安全性），服务端会更新自己的随机数 a 和公钥，再生成新的密钥 S，然后把公钥通过 Server Hello 发送给客户端。连同 Server Hello 消息，还有 HTTP 返回数据；<br>客户端收到 Server Hello 后，生成与服务端一致的新密钥 S，后面的传输都使用 S 加密。<br>这样，QUIC 从请求连接到正式接发 HTTP 数据一共花了 1 RTT，这 1 个 RTT 主要是为了获取 Server Config，后面的连接如果客户端缓存了 Server Config，那么就可以直接发送 HTTP 数据，实现 0 RTT 建立连接。</p><p>这里使用的是 DH 密钥交换算法，DH 算法的核心就是服务端生成 a、g、p 3 个随机数，a 自己持有，g 和 p 要传输给客户端，而客户端会生成 b 这 1 个随机数，通过 DH 算法客户端和服务端可以算出同样的密钥。在这过程中 a 和 b 并不参与网络传输，安全性大大提高。因为 p 和 g 是大数，所以即使在网络中传输的 p、g、A、B 都被劫持，那么靠现在的计算机算力也没法破解密钥。</p><h4 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h4><p><img src="/./IOT-Protocol-HTTP/image-20250602200327336.png" alt="image-20250602200327336"></p><p>TCP 连接基于四元组（源 IP、源端口、目的 IP、目的端口），切换网络时至少会有一个因素发生变化，导致连接发生变化。当连接发生变化时，如果还使用原来的 TCP 连接，则会导致连接失败，就得等原来的连接超时后重新建立连接，所以我们有时候发现切换到一个新网络时，即使新网络状况良好，但内容还是需要加载很久。如果实现得好，当检测到网络变化时立刻建立新的 TCP 连接，即使这样，建立新的连接还是需要几百毫秒的时间。</p><p>QUIC 的连接不受四元组的影响，当这四个元素发生变化时，原连接依然维持。那这是怎么做到的呢？道理很简单，QUIC 连接不以四元组作为标识，而是使用一个 64 位的随机数，这个随机数被称为 Connection ID，即使 IP 或者端口发生变化，只要 Connection ID 没有变化，那么连接依然可以维持。</p><h4 id="队头阻塞和多路复用"><a href="#队头阻塞和多路复用" class="headerlink" title="队头阻塞和多路复用"></a>队头阻塞和多路复用</h4><p><img src="/./IOT-Protocol-HTTP/image-20250602200340992.png" alt="image-20250602200340992"><br><img src="/./IOT-Protocol-HTTP/image-20250602200350425.png" alt="image-20250602200350425"></p><p>队头阻塞会导致 HTTP&#x2F;2 在更容易丢包的弱网络环境下比 HTTP&#x2F;1.1 更慢！</p><p>那 QUIC 是如何解决队头阻塞问题的呢？主要有两点。</p><p>QUIC 的传输单元是 Packet，加密单元也是 Packet，整个加密、传输、解密都基于 Packet，这样就能避免 TLS 的队头阻塞问题<br>QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>拥塞控制的目的是避免过多的数据一下子涌入网络，导致网络超出最大负荷。QUIC 的拥塞控制与 TCP 类似，并在此基础上做了改进。所以我们先简单介绍下 TCP 的拥塞控制。</p><p>TCP 拥塞控制由 4 个核心算法组成：慢启动、拥塞避免、快速重传和快速恢复，理解了这 4 个算法，对 TCP 的拥塞控制也就有了大概了解。</p><p>慢启动：发送方向接收方发送 1 个单位的数据，收到对方确认后会发送 2 个单位的数据，然后依次是 4 个、8 个……呈指数级增长，这个过程就是在不断试探网络的拥塞程度，超出阈值则会导致网络拥塞；<br>拥塞避免：指数增长不可能是无限的，到达某个限制（慢启动阈值）之后，指数增长变为线性增长；<br>快速重传：发送方每一次发送时都会设置一个超时计时器，超时后即认为丢失，需要重发；<br>快速恢复：在上面快速重传的基础上，发送方重新发送数据时，也会启动一个超时定时器，如果收到确认消息则进入拥塞避免阶段，如果仍然超时，则回到慢启动阶段。<br>QUIC 重新实现了 TCP 协议的 Cubic 算法进行拥塞控制，并在此基础上做了不少改进。下面介绍一些 QUIC 改进的拥塞控制的特性。</p><p>热插拔<br>TCP 中如果要修改拥塞控制策略，需要在系统层面进行操作。QUIC 修改拥塞控制策略只需要在应用层操作，并且 QUIC 会根据不同的网络环境、用户来动态选择拥塞控制算法。</p><h4 id="前向纠错-FEC"><a href="#前向纠错-FEC" class="headerlink" title="前向纠错 FEC"></a>前向纠错 FEC</h4><p><img src="/./IOT-Protocol-HTTP/image-20250602200509620.png" alt="image-20250602200509620"></p><p>QUIC 使用前向纠错（FEC，Forward Error Correction）技术增加协议的容错性。一段数据被切分为 10 个包后，依次对每个包进行异或运算，运算结果会作为 FEC 包与数据包一起被传输，如果不幸在传输过程中有一个数据包丢失，那么就可以根据剩余 9 个包以及 FEC 包推算出丢失的那个包的数据，这样就大大增加了协议的容错性。</p><p>这是符合现阶段网络技术的一种方案，现阶段带宽已经不是网络传输的瓶颈，往返时间才是，所以新的网络传输协议可以适当增加数据冗余，减少重传操作。</p><h4 id="单调递增的-Packet-Number"><a href="#单调递增的-Packet-Number" class="headerlink" title="单调递增的 Packet Number"></a>单调递增的 Packet Number</h4><p>TCP 为了保证可靠性，使用 Sequence Number 和 ACK 来确认消息是否有序到达，但这样的设计存在缺陷。</p><p>超时发生后客户端发起重传，后来接收到了 ACK 确认消息，但因为原始请求和重传请求接收到的 ACK 消息一样，所以客户端就郁闷了，不知道这个 ACK 对应的是原始请求还是重传请求。如果客户端认为是原始请求的 ACK，但实际上是左图的情形，则计算的采样 RTT 偏大；如果客户端认为是重传请求的 ACK，但实际上是右图的情形，又会导致采样 RTT 偏小。图中有几个术语，RTO 是指超时重传时间（Retransmission TimeOut），跟我们熟悉的 RTT（Round Trip Time，往返时间）很长得很像。采样 RTT 会影响 RTO 计算，超时时间的准确把握很重要，长了短了都不合适。</p><p>QUIC 解决了上面的歧义问题。与 Sequence Number 不同的是，Packet Number 严格单调递增，如果 Packet N 丢失了，那么重传时 Packet 的标识不会是 N，而是比 N 大的数字，比如 N + M，这样发送方接收到确认消息时就能方便地知道 ACK 对应的是原始请求还是重传请求。</p><h4 id="ACK-Delay"><a href="#ACK-Delay" class="headerlink" title="ACK Delay"></a>ACK Delay</h4><p><img src="/./IOT-Protocol-HTTP/image-20250602200633799.png" alt="image-20250602200633799"></p><p>TCP 计算 RTT 时没有考虑接收方接收到数据到发送确认消息之间的延迟，如下图所示，这段延迟即 ACK Delay。QUIC 考虑了这段延迟，使得 RTT 的计算更加准确。</p><h4 id="更多的-ACK-块"><a href="#更多的-ACK-块" class="headerlink" title="更多的 ACK 块"></a>更多的 ACK 块</h4><p><img src="/./IOT-Protocol-HTTP/image-20250602200644643.png" alt="image-20250602200644643"></p><p>一般来说，接收方收到发送方的消息后都应该发送一个 ACK 回复，表示收到了数据。但每收到一个数据就返回一个 ACK 回复太麻烦，所以一般不会立即回复，而是接收到多个数据后再回复，TCP SACK 最多提供 3 个 ACK block。但有些场景下，比如下载，只需要服务器返回数据就好，但按照 TCP 的设计，每收到 3 个数据包就要“礼貌性”地返回一个 ACK。而 QUIC 最多可以捎带 256 个 ACK block。在丢包率比较严重的网络下，更多的 ACK block 可以减少重传量，提升网络效率。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>TCP 会对每个 TCP 连接进行流量控制，流量控制的意思是让发送方不要发送太快，要让接收方来得及接收，不然会导致数据溢出而丢失，TCP 的流量控制主要通过滑动窗口来实现的。可以看出，拥塞控制主要是控制发送方的发送策略，但没有考虑到接收方的接收能力，流量控制是对这部分能力的补齐。</p><p>QUIC 只需要建立一条连接，在这条连接上同时传输多条 Stream，好比有一条道路，两头分别有一个仓库，道路中有很多车辆运送物资。QUIC 的流量控制有两个级别：连接级别（Connection Level）和 Stream 级别（Stream Level），好比既要控制这条路的总流量，不要一下子很多车辆涌进来，货物来不及处理，也不能一个车辆一下子运送很多货物，这样货物也来不及处理。</p><p>那 QUIC 是怎么实现流量控制的呢？我们先看单条 Stream 的流量控制。Stream 还没传输数据时，接收窗口（flow control receive window）就是最大接收窗口（flow control receive window），随着接收方接收到数据后，接收窗口不断缩小。在接收到的数据中，有的数据已被处理，而有的数据还没来得及被处理。如下图所示，蓝色块表示已处理数据，黄色块表示未处理数据，这部分数据的到来，使得 Stream 的接收窗口缩小。<br><img src="/./IOT-Protocol-HTTP/image-20250602200702212.png" alt="image-20250602200702212"></p><p>随着数据不断被处理，接收方就有能力处理更多数据。当满足 (flow control receive offset - consumed bytes) &lt; (max receive window &#x2F; 2) 时，接收方会发送 WINDOW_UPDATE frame 告诉发送方你可以再多发送些数据过来。这时 flow control receive offset 就会偏移，接收窗口增大，发送方可以发送更多数据到接收方。</p><p>Stream 级别对防止接收端接收过多数据作用有限，更需要借助 Connection 级别的流量控制。理解了 Stream 流量那么也很好理解 Connection 流控。Stream 中，接收窗口(flow control receive window) &#x3D; 最大接收窗口(max receive window) - 已接收数据(highest received byte offset) ，而对 Connection 来说：接收窗口 &#x3D; Stream1 接收窗口 + Stream2 接收窗口 + … + StreamN 接收窗口 。<br><img src="/./IOT-Protocol-HTTP/image-20250602200715976.png" alt="image-20250602200715976"></p>]]></content>
    
    
    
    <tags>
      
      <tag>protocol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unsortedbin_attack</title>
    <link href="/unsortedbin-attack/"/>
    <url>/unsortedbin-attack/</url>
    
    <content type="html"><![CDATA[<h1 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin_attack"></a>unsortedbin_attack</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>​最近想把how2heap的内容补补，之前都是在本地写的文章，正好最近没怎么看看Heap的内容了，接着把之前的内容续上顺便复习一下。<br>本篇文章就是学习unsortedbin的原理，根据unsortedbin的源码和how2heap的源码着手。原理不难就顺便写个文章记录一下。</p></blockquote><h2 id="unsortedbin的原理"><a href="#unsortedbin的原理" class="headerlink" title="unsortedbin的原理"></a>unsortedbin的原理</h2><p><strong>控制bk指针：</strong><br>    攻击者通过修改未排序池中块的bk指针（指向后一个释放的块的地址），可以将目标地址写入任意位置。例如，将bk指针指向main_arena的地址，从而覆盖全局变量或堆内存。<br><strong>任意地址写入：</strong><br>    通过构造假的内存块，将上一个实际块的bk指针指向目标地址，实现对堆内存的覆盖。例如，修改main_arena的地址，使后续的malloc操作返回伪造的堆块。<br><strong>绕过安全检查：</strong><br>    在glibc 2.23至2.29版本中，攻击者通过修改bk指针指向main_arena的地址，绕过__malloc_hook的检查，实现任意地址写入。</p><h2 id="unsortedbin的机制"><a href="#unsortedbin的机制" class="headerlink" title="unsortedbin的机制"></a>unsortedbin的机制</h2><p><strong>内存分配流程</strong>：<br>    当程序请求分配内存时，若快速池（fast bin）和小型池（small bin）中无匹配大小的块，系统会从未排序池（unsorted bin）中寻找。若找到的块大小满足需求，直接返回；否则，将块插入到对应池中。<br><strong>未排序池的结构</strong>：<br>    未排序池采用双向链表结构，遵循先进先出（FIFO）原则。新块插入链表头部，分配时从链表尾部遍历。</p><h2 id="unsortedbin-基本来源"><a href="#unsortedbin-基本来源" class="headerlink" title="unsortedbin 基本来源"></a>unsortedbin 基本来源</h2><ul><li>当一个较大的（在bin中的）chunk（由于malloc）被分割成两半之后，如果剩下的部分大于MINSIZE，就会被放到unsortedbin中。<br>举个例子，如有个0x90大小的 small chunk，此时malloc(0x60)，剩下的0x30由于大于 MINSIZE ，会被放入unsortedbin 中。</li><li>释放一个不属于fastbin的chunk，并且该chunk不和top_chunk紧邻时，该chunk会首先被放到unsortedbin中。</li><li>当进行malloc_consolidate时，如果不是和top_chunk近邻的话，可能会把合并后的chunk放到unsortedbin中。</li></ul><h2 id="2-23-unsortedbin源码分析"><a href="#2-23-unsortedbin源码分析" class="headerlink" title="2.23-unsortedbin源码分析"></a>2.23-unsortedbin源码分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs c">#源码的第<span class="hljs-number">3470</span>行<span class="hljs-number">-3597</span>行<br>         <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>#取链表尾部的chunk记作victim<br>        &#123;<br>          bck = victim-&gt;bk;<br>          <span class="hljs-meta">#bk指针是指向当前chunk的上一个chunk的，bck是victim的上一个chunk</span><br>         <br>          <span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>#检查内存块的大小是否小于等于<span class="hljs-number">2</span> * SIZE_SZ（即MINSIZE，通常为<span class="hljs-number">32</span>字节）。<br>              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>#检查内存块的大小是否超过当前分配区的总内存（av-&gt;system_mem）。<br>            malloc_printerr (check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                             chunk2mem (victim), av);<br><br>          size = chunksize (victim);<br>  #检查通过，计算victim得到实际chunk的大小<br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">             only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">             runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">             exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">             no exact fit for a small chunk.</span><br><span class="hljs-comment">           */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>              bck == unsorted_chunks (av) &amp;&amp;<br>              victim == av-&gt;last_remainder &amp;&amp;<br>              (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br><span class="hljs-meta">#nb是用户请求的内存大小（requested size）。</span><br><span class="hljs-meta">#av是当前分配区的上下文指针（arena），指向main_arena（默认分配区）或通过malloc_get_arena指定的其他分配区。</span><br>#假如说我们申请的<span class="hljs-built_in">malloc</span>大小属于smallbin的范围，并且last_remainder是unsortedbin的唯一一个chunk时，优先使用这个chunk。<br>              <br>            &#123;<br>              <br>              <span class="hljs-comment">/* split and reattach remainder */</span><br>              remainder_size = size - nb;<br>              remainder = chunk_at_offset (victim, nb);<br>              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>              av-&gt;last_remainder = remainder;<br>              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>#将分割后的chunk重新链接到unsortedbin(av)和last_remainder的指针链上<br><br>              <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                &#123;<br>                  remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                  remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                &#125;<br><br>              set_head (victim, nb | PREV_INUSE |<br>                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>              set_head (remainder, remainder_size | PREV_INUSE);<br>              set_foot (remainder, remainder_size);<br><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br> #如果上述条件不满足，则将victim从链中取出之后放到合适的链中或返回给用户。<br>          #其中unsorted_chunks (av)-&gt;bk = bck;<br>          <span class="hljs-meta">#bck-&gt;fd = unsorted_chunks (av);</span><br>          #是unsorted bin attack产生的原因，<br>          #一旦我们绕过之前的检查到达这里，<br>          #在可以控制victim-&gt;bk即bck的情况下我们可以往bck-&gt;fd写入unsorted_chunks(av)<br>          #即*(bck+<span class="hljs-number">0x10</span>)=unsorted(av)。<br><br>          <span class="hljs-comment">/* remove from unsorted list */</span><br>          <span class="hljs-meta">#unsortedbin产生的原因：</span><br>          unsorted_chunks (av)-&gt;bk = bck;<br>          bck-&gt;fd = unsorted_chunks (av);<br>  #<br>          <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br>      #如果我们请求的nb同victim的大小恰好吻合，就直接返回这个块给用户。<br>          <span class="hljs-keyword">if</span> (size == nb)<br>            &#123;<br>              set_inuse_bit_at_offset (victim, size);<br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                victim-&gt;size |= NON_MAIN_ARENA;<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>                  <br>          <span class="hljs-comment">/* place chunk in bin */</span><br>  #如果之前的条件都不满足，意味着目前的victim不能满足用户的需求，<br>          #需要根据其size放入small bin或large bin的链，<br>          #其中在后者实现中存在large bin attack，<br>          #由于同本文无关就不再进一步展开，最后是unlink将victim彻底解链。<br>          <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>            &#123;<br>              victim_index = smallbin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br>            &#125;<br>          <span class="hljs-keyword">else</span><br>            &#123;<br>              victim_index = largebin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br><br>              <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>              <span class="hljs-keyword">if</span> (fwd != bck)<br>                &#123;<br>                  <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                  size |= PREV_INUSE;<br>                  <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>                    &#123;<br>                      fwd = bck;<br>                      bck = bck-&gt;bk;<br><br>                      victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                      <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>                        &#123;<br>                          fwd = fwd-&gt;fd_nextsize;<br>                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                        &#125;<br><br>                      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          victim-&gt;fd_nextsize = fwd;<br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                          fwd-&gt;bk_nextsize = victim;<br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                      bck = fwd-&gt;bk;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>            &#125;<br><br>          mark_bin (av, victim_index);<br>          victim-&gt;bk = bck;<br>          victim-&gt;fd = fwd;<br>          fwd-&gt;bk = victim;<br>          bck-&gt;fd = victim;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ITERS       10000</span><br>          <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br></code></pre></td></tr></table></figure><h2 id="how2heap源码编译及分析"><a href="#how2heap源码编译及分析" class="headerlink" title="how2heap源码编译及分析"></a>how2heap源码编译及分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;This file demonstrates unsorted bin attack by write a large unsigned long value into stack\n&quot;</span>);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the &quot;</span><br>                   <span class="hljs-string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);<br><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:\n&quot;</span>);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %ld\n\n&quot;</span>, &amp;stack_var, stack_var);<br><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,p);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;</span><br>           <span class="hljs-string">&quot;the first one during the free()\n\n&quot;</span>);<br>        <span class="hljs-built_in">malloc</span>(<span class="hljs-number">500</span>);<br><br>        <span class="hljs-built_in">free</span>(p);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;</span><br>                   <span class="hljs-string">&quot;point to %p\n&quot;</span>,(<span class="hljs-type">void</span>*)p[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-comment">//------------VULNERABILITY-----------</span><br><br>        p[<span class="hljs-number">1</span>]=(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var<span class="hljs-number">-2</span>);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n&quot;</span>,(<span class="hljs-type">void</span>*)p[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-comment">//------------------------------------</span><br><br>        <span class="hljs-built_in">malloc</span>(<span class="hljs-number">400</span>);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Let&#x27;s malloc again to get the chunk we just free. During this time, the target should have already been &quot;</span><br>                   <span class="hljs-string">&quot;rewritten:\n&quot;</span>);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%p: %p\n&quot;</span>, &amp;stack_var, (<span class="hljs-type">void</span>*)stack_var);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="梳理流程："><a href="#梳理流程：" class="headerlink" title="梳理流程："></a>梳理流程：</h3><p>​首先我们先创建一个全局变量stack_var&#x3D;0,他应该是位于bss段的样子，申请了两个chunk，第二个chunk的作用是用来隔离top chunk的，然后我们将第一个chunk的指针free掉，重点来了，指针p的地址放的是malloc（400）分配的数据段的起始地址，也就是相当于chunk在bin中的fd指针的位置，那么由于地址是连续分配的，所以p[1]放的地址就是相当于bk的地址位置，我们将p[1]的地址改成了&amp;stack_var-2，也就是说&amp;stack_var-2相当于取stack_var的变量的地址减去两个0x8，这里我讲一下为什么要减去0x10的大小，在64位系统中，堆块头部的 size 字段占用8字节，而 bk 字段也占用8字节。因此，stack_var 地址减去16字节正好指向 stack_var 的起始位置。这样做的目的是让 p[1] 指向 stack_var 的起始位置，从而在再次分配堆块时，glibc会将 stack_var 的值修改为堆块的地址。</p><h3 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h3><p>我们现在来看gdb的调试</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">gcc -<span class="hljs-selector-tag">g</span> demo<span class="hljs-selector-class">.c</span> -o demo<br># -<span class="hljs-selector-tag">g</span> 参数是将调试信息加载加来，方便我们调试<br></code></pre></td></tr></table></figure><p>我们先运行到申请stack_var的地方，这个时候p的地方还没赋值呢，我们往下走</p><p><img src="/./unsortedbin-attack/image-20250529225347268.png" alt="image-20250529225347268"></p><p>我们可以看到这个时候stack_var的地址是<strong>0x7ffd968cdb98</strong>,我们进去看看发现这个时候里面的值确实是0，</p><p><img src="/./unsortedbin-attack/image-20250529225701943.png" alt="image-20250529225701943"><br><img src="/./unsortedbin-attack/image-20250529225851693.png" alt="image-20250529225851693"></p><p>当我们运行到free的时候我们看到这个时候bin中chunk的fd与bk的值都是指向unsorted_chunks (av)的<br><img src="/./unsortedbin-attack/image-20250529230043924.png" alt="image-20250529230043924"></p><p>我们可以看到bk的指针指向的地方有已经变成了&amp;stack_var-0x10的值了<br><img src="/./unsortedbin-attack/image-20250529230612438.png" alt="image-20250529230612438"><img src="/./unsortedbin-attack/image-20250529230359289.png" alt="image-20250529230359289"></p><p>至此已经将fake的chunk链接进bin中了，下一步申请出来就行了。</p><p>总结：</p><p>​这个技术和之前的fastbin_dup_into_stack很像，无非就是篡改指针指向我们构造好的fake_chunk的地址，然后申请出来，对这个chunk拥有控制权。<br>放眼其他的bin的利用有时也是如此，其他的bin的利用方法就是根据其他bin的特性去利用构造。<br>等有空我将其他bin的分析的文章搬到page上。</p>]]></content>
    
    
    
    <tags>
      
      <tag>how2heap-2.23</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOT-Protocol-Coap</title>
    <link href="/IOT-Protocol-coap/"/>
    <url>/IOT-Protocol-coap/</url>
    
    <content type="html"><![CDATA[<h1 id="IOT协议之Coap"><a href="#IOT协议之Coap" class="headerlink" title="IOT协议之Coap"></a>IOT协议之Coap</h1><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇讲的是MQTT协议，今天就讲讲Coap协议吧，两者都是应用层协议，我们也是从原理加抓包分析起手</p><hr><h2 id="什么是Coap协议？"><a href="#什么是Coap协议？" class="headerlink" title="什么是Coap协议？"></a>什么是Coap协议？</h2><p>​受限应用协议（CoAP）是一种专门的web传输协议，用于受限节点和受限（例如，低功耗、有损）网络。节点通常有8位微控制器，带有少量ROM和RAM，而受限网络，如低功率无线个人区域网络（6LoWPANs）上的IPv6，通常具有高分组错误率和10s kbit&#x2F;s的典型吞吐量。<br>​该协议设计用于机器对机器（M2M）应用，如智能能源和楼宇自动化。CoAP提供应用程序端点之间的请求&#x2F;响应交互模型，支持内置的服务和资源发现，并包括Web的关键概念，如URI和Internet媒体类型。<br>​CoAP的设计目的是方便地与HTTP接口，以便与Web集成，同时满足特定的需求，如多播支持、非常低的开销以及受限环境的简单性。</p><h4 id="CoAP的核心特性"><a href="#CoAP的核心特性" class="headerlink" title="CoAP的核心特性"></a><strong>CoAP的核心特性</strong></h4><ol><li><strong>轻量高效</strong><ul><li>CoAP基于<strong>UDP协议</strong>设计，头部仅需4字节，通信开销远低于HTTP的TCP连接。</li><li>支持二进制格式报文，最小消息长度仅4字节，适合RAM&#x2F;ROM有限的设备。</li></ul></li><li><strong>RESTful架构</strong><ul><li>遵循HTTP的REST风格，使用URI标识资源，支持GET、POST、PUT、DELETE方法。</li><li>通过简化的请求&#x2F;响应模型，实现设备与云端的高效交互。</li></ul></li><li><strong>可靠性与灵活性</strong><ul><li>定义4种消息类型： <strong>CON（需确认）</strong> 、 <strong>NON（非确认）</strong> 、 <strong>ACK（确认响应）</strong> 、 <strong>RST（重置）</strong> ，通过重传机制保障可靠性。</li><li>支持<strong>IP多播</strong>，可同时向多个设备发送指令，适用于智能家居等场景。</li></ul></li><li><strong>安全性</strong><ul><li>集成DTLS（数据报传输层安全协议），提供身份认证、数据完整性和加密功能。</li><li>可通过TLS和WebSocket扩展支持更复杂的安全需求。</li></ul></li></ol><hr><h2 id="Coap的通信模型"><a href="#Coap的通信模型" class="headerlink" title="Coap的通信模型"></a>Coap的通信模型</h2><p>​CoAP的消息模型是建立在UDP端到端通信的基础上的。</p><p>​CoAP的头部为固定长度的（4个字节）二进制格式，其后是紧凑的二进制格式的选项部分，然后是数据部分(payload)，请求和响应都采用这种格式。每个消息都包含一个消息ID，用于检测重复提供传输可靠性。（这个消息ID是连续的，包含有16位，在默认的协议参数配置下，它允许每秒钟从一端到另一端传输大约250条消息）。</p><p>​通过把消息标记为CON的，可以保障消息传输的可靠性。如图2所示，在收到一个CON消息之后，接收端会发送一个带有相同消息ID(Message ID)（在这个例子中是0x7d34）的ACK。如果在默认的超时时间之后没有收到带有相同消息ID的ACK，那么它将会被重传，如果仍然没有收到ACK，此后重传超时时间会以指数级递增。当接收端无法处理一个CON消息(也无法返回一个正常的错误响应)时，它将会回应一个RST消息，而不是ACK。</p><pre><code class="hljs">                Client              Server                   |                  |                   |   CON [0x7d34]   |                   +-----------------&gt;|                   |                  |                   |   ACK [0x7d34]   |                   |&lt;-----------------+                   |                  |                 图2 可靠消息传输</code></pre><h3 id="与HTTP的对比"><a href="#与HTTP的对比" class="headerlink" title="与HTTP的对比"></a><strong>与HTTP的对比</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>CoAP</strong></th><th><strong>HTTP</strong></th></tr></thead><tbody><tr><td>传输层</td><td>UDP（低开销）</td><td>TCP（可靠但复杂）</td></tr><tr><td>消息大小</td><td>轻量（4字节起）</td><td>较大（头部冗余）</td></tr><tr><td>适用场景</td><td>受限设备、弱网环境</td><td>高带宽、稳定网络</td></tr><tr><td>多播支持</td><td>是</td><td>否</td></tr></tbody></table><hr><h2 id="Coap的报文格式与结构"><a href="#Coap的报文格式与结构" class="headerlink" title="Coap的报文格式与结构"></a>Coap的报文格式与结构</h2><ol><li><p><strong>报文结构</strong>  </p><p>CoAP报文分为<strong>头部</strong>（header）、 <strong>选项（Options）</strong> 和 <strong>负载（Payload）</strong>：  </p><ul><li><p><strong>头部</strong>：包含版本号（Ver）、消息类型（T）、令牌长度（TKL）、状态码（Code）和消息ID。  </p></li><li><p><strong>选项</strong>：用于指定URI路径、媒体类型（如JSON、CBOR）等参数，支持链式扩展。  </p></li><li><p><strong>负载</strong>：以<code>0xFF</code>分隔，支持多种数据格式。</p></li></ul><p><img src="/./IOT-Protocol-coap/image-20250526063657847.png" alt="image-20250526063657847"></p><p><strong>头部字段定义如下</strong>：</p><p>​<strong>版本号(Ver)：</strong>2-bit无符号整型，代表CoAP版本号。本文档的实现必须设置这个字段为0b01。其它的值为今后其它版本保留。对于带有未知版本号的消息，必须忽略。</p><p>​<strong>类型(T)：</strong>2-bit无符号整型。代表这个消息的类型是：CON(0), NON(1), ACK(2),或RST(3)。</p><p>​<strong>Token长度(TKL)：</strong>4-bit无符号整型。表示变长的Token字段(0-8字节）的长度。长度9-15是保留的，不能设置长度为9-15。如果设置了长度为9-15，必须被当作消息格式错误来处理。</p><p>​<strong>代码(Code)：</strong>8-bit无符号整型。拆分为3-bit的分类信息和5-bit详细信息。写作”c.dd”。c是3-bit长，可以是一个从0到7的数字，dd是5-bit长，它一个两位的数字，从00到31。分类信息c可以代表是一个请求（0），一个成功的响应（2），一个客户端错误响应（4），或者一个服务端错误响应（5）。所有其它的值都是保留的。代码0.00是一个特殊的情况，表示一个空的消息。当消息是一个请求时，Code字段表示请求方法。当响应时，Code字段代表响应代码。请求和响应的语义定义在第5章。</p><p>​<strong>消息ID(Message ID)：</strong>16-bit无符号整型，网络字节序。用于检测消息重复以及匹配ACK&#x2F;RST类型的消息和CON&#x2F;NON类型的消息。生成消息ID和匹配消息的规则在第4章中讲述。</p><p>​头部之后是<strong>Token值</strong>，可以有0到8个字节，由Token长度字段指定。这个Token值用于将某个请求和对应的响应关联。</p><p>​头部和Token之后，<strong>是0个或多个选项</strong>。一个选项之后，有可能是消息结束，也可能是另一个选项，也可能是payload标识符和payload部分。</p><p>​在头部、token和选项之后，是<strong>payload部分</strong>（可以没有payload）。如果有payload，并且长度不为0，那么payload之前有一个固定长度为一个字节的payload标识符（0xFF），它标志着选项部分的结束和payload部分的开始。payload部分从标识符之后开始，一直到这个UDP数据报结束，也就是说，payload部分的长度可以根据UDP数据报的长度计算出来。如果没有payload标识符，那么就代表这是一个0长度的payload。如果存在payload标识符但其后跟随的是0长度的payload，那么必须当作消息格式错误处理。</p><p>​实现注意：0xFF这个值有可能出现在一个选项的长度或选项的值中，所以简单的扫描0xFF来寻找payload标识符是不可行的。作为payload标识符的0xFF只可能出现在一个选项结束之后下一个选项有可能开始的地方。</p><p><strong>option的详细解析</strong></p><p>​CoAP定义了许多option。消息中的每个option都有一个option编号，option值长度，和option值。 消息中的option号（TLV格式中的T）并不是直接指定option编号的。所有的option必须按实际option编号的递增排列，某一个option和上一个option之间的option编号差值为delta；每一个TLV格式的option号都是delta值（数据包中第一个option的delta即它的option编号）。同一个编号的option再次出现时，delta的值为0。<br><img src="/./IOT-Protocol-coap/image-20250526064948717.png" alt="image-20250526064948717"></p><p>CoAP中所有的Option都采用编号的方式，这些Option及编号的定义如下图所示。<img src="/./IOT-Protocol-coap/image-20250526070635305.png" alt="image-20250526070635305"></p></li><li><p><strong>双层架构</strong>  </p><ul><li><strong>事务层</strong>：基于UDP处理消息传输，提供重传和拥塞控制。  </li><li><strong>请求&#x2F;响应层</strong>：封装资源操作逻辑，与HTTP语义兼容。</li></ul><p>​从逻辑上，可以把CoAP协议划分为两层：消息层，用于处理UDP数据包和异步；请求&#x2F;响应层，使用Method和Response Code，具体见图1。当然，CoAP是一个协议，消息和请求&#x2F;响应仅仅是其头部特性。</p><pre><code class="hljs">    +----------------------+    |      Application     |    +----------------------+    +----------------------+  \    |  Requests/Responses  |  |    |----------------------|  | CoAP    |       Messages       |  |    +----------------------+  /    +----------------------+    |          UDP         |    +----------------------+    图1 CoAP中的抽象层次</code></pre></li><li><p><strong>典型流程</strong>  </p><ul><li>设备通过<strong>CON报文</strong>注册到平台，发送数据或接收指令。  </li><li>使用<strong>NON报文</strong>发送心跳维持连接，减少网络负载。</li></ul></li></ol><hr><h2 id="Coap的消息类型"><a href="#Coap的消息类型" class="headerlink" title="Coap的消息类型"></a>Coap的消息类型</h2><p><strong>COAP协议有4种消息类型：</strong></p><ul><li>CON—— 需要被确认的请求，如果CON请求被发送，那么对方必须做出响应。这有点像TCP，对方必须给确认收到消息，用以可靠消息传输。</li><li>NON—— 不需要被确认的请求，如果NON请求被发送，那么对方不必做出回应。这适用于消息会重复频繁的发送，丢包不影响正常操作。这个和UDP很像。用以不可靠消息传输。</li><li>ACK —— 应答消息，对应的是CON消息的应答。</li><li>RST —— 复位消息，可靠传输时候接收的消息不认识或错误时，不能回ACK消息，必须回RST消息。</li></ul><h2 id="实践抓包分析"><a href="#实践抓包分析" class="headerlink" title="实践抓包分析"></a>实践抓包分析</h2><h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><p>我们需要进行下载一个Coap的客户端，这里我用的Coap_shell,下载链接放在下面了<br><code>链接: https://pan.baidu.com/s/1soGdqIlOBQe968_wezxq7Q 密码: rw6o</code></p><p>下载完之后在命令行运行<br><code>java -jar coap-shell.jar</code></p><p>可以用coap:&#x2F;&#x2F;coap.me作为测试服务器，输入下列命令连接服务器：<br><img src="/./IOT-Protocol-coap/image-20250526073545501.png" alt="image-20250526073545501"></p><p>wireshark的捕获方式使用的是WLAN<br><img src="/./IOT-Protocol-coap/image-20250526074148979.png" alt="image-20250526074148979"></p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>运行discover,发现资源<br><img src="/./IOT-Protocol-coap/image-20250526074431703.png" alt="image-20250526074431703"></p><p>我们可以使用GET,POST,PUT,DELETE的请求方式进行资源的操作。</p><h4 id="以con类型为例"><a href="#以con类型为例" class="headerlink" title="以con类型为例"></a>以con类型为例</h4><p>我们先运行get &#x2F;hello<br><img src="/./IOT-Protocol-coap/image-20250526075038241.png" alt="image-20250526075038241"></p><p>使用wireshark抓包分析</p><p><img src="/./IOT-Protocol-coap/image-20250526074844346.png" alt="image-20250526074844346"></p><p>我们进入CON的报文类型中分析，对比一下上面图片的报文格式</p><ul><li>version是比特01</li><li>type是比特00，内容是confirmable</li><li>token length是比特1000</li></ul><p>这三个组成了一个字节</p><ul><li><p>code的请求方法是get</p></li><li><p>Message ID是355196是里两个字节</p></li><li><p>token一共是16个十六进制的数也就是8个字节</p></li></ul><p><img src="/./IOT-Protocol-coap/image-20250526075306891.png" alt="image-20250526075306891"></p><p>我们现在来看看option的部分<br>这个CON的消息类型中存在三个option选项，opt Delta的比特是0011，opt length的比特是0101，两个加一块正好是一个字节，符合下面的这个图，uri-host是属于option value，是7个字节，剩下的两个option也是如此。<br><img src="/./IOT-Protocol-coap/image-20250526081500420.png" alt="image-20250526081500420"></p><p><img src="/./IOT-Protocol-coap/image-20250526080951327.png" alt="image-20250526080951327"><br>这个con里面不存在payload，我们也可以看到没有0xff的十六进制。</p><h4 id="以ack类型为例"><a href="#以ack类型为例" class="headerlink" title="以ack类型为例"></a>以ack类型为例</h4><p>前面的分析就跳过了，直接步入payload的分析，我们可以看到0xff的后面就是payload的内容了，world，是五个字节的长度，正好是world的ascll码<br><img src="/./IOT-Protocol-coap/image-20250526082611509.png" alt="image-20250526082611509"></p><p><img src="/./IOT-Protocol-coap/image-20250526082048066.png" alt="image-20250526082048066"></p><p>​其他的请求方式，或RST,NON的类型就不分析了，我没时间去构造这样的情况了。反正分析起来就是如此了，想深入分析的话建议还是去建议看官方文档，那里面很详细，做协议开发的话还是得仔细看的，等到后卖面再用到的话再说吧。</p>]]></content>
    
    
    
    <tags>
      
      <tag>protocol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOT_Protocol_MQTT</title>
    <link href="/IOT-Protocol-MQTT/"/>
    <url>/IOT-Protocol-MQTT/</url>
    
    <content type="html"><![CDATA[<h1 id="IOT协议之MQTT"><a href="#IOT协议之MQTT" class="headerlink" title="IOT协议之MQTT"></a>IOT协议之MQTT</h1><hr><p>​最近正在开始接触IOT的固件的漏洞挖掘，刚开始还是感觉很迷惑的，不知从哪里下手，我想还是边学习边复现，顺便把相关的常用的传输协议也学了吧，遂有了今天的这篇文章，以此做个记录。</p><hr><h2 id="1-什么是MQTT协议？"><a href="#1-什么是MQTT协议？" class="headerlink" title="1.什么是MQTT协议？"></a>1.什么是MQTT协议？</h2><p>​MQTT协议（Message Queuing Telemetry Transport，消息队列遥测传输协议）是一种基于发布&#x2F;订阅模式的轻量级通信协议，由IBM的Andy Stanford-Clark和Arlen Nipper于1999年发明，旨在为低带宽、高延迟或不稳定的网络环境设计，如物联网（IoT）设备之间的通信。</p><p>​<img src="/./IOT-Protocol-MQTT/image-20250524170116764.png" alt="image-20250524170116764"></p><p>​MQTT是一种基于TCP&#x2F;IP协议的轻量级通信协议，属于应用层协议，用于实现设备间的高效消息传输。位于OSI模型的第5至7层，其中第7层是应用层。</p><h3 id="1-1核心特点"><a href="#1-1核心特点" class="headerlink" title="1.1核心特点"></a>1.1核心特点</h3><ul><li>基于 TCP&#x2F;IP（应用层协议）。</li><li>低功耗、低开销（最小报文仅 2 字节）。</li><li>支持 QoS（服务质量等级）。</li><li>适合设备间异步通信。</li></ul><hr><h2 id="2-MQTT通信模型"><a href="#2-MQTT通信模型" class="headerlink" title="2.MQTT通信模型"></a>2.MQTT通信模型</h2><p>​MQTT采用<strong>发布&#x2F;订阅（Publish-Subscribe）模型</strong>，与传统的<strong>客户端&#x2F;服务器（Client-Server）模型</strong>（如HTTP）有本质区别。其核心思想是 <strong>解耦消息的发送者（Publisher）和接收者（Subscriber）</strong> ，通过代理服务器（Broker）实现高效、灵活的消息路由。</p><p><img src="/./IOT-Protocol-MQTT/image-20250524233158429.png" alt="image-20250524233158429"></p><table><thead><tr><th><strong>角色</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>Publisher（发布者）</strong></td><td>向Broker发送消息的客户端（如传感器、设备）。</td></tr><tr><td><strong>Subscriber（订阅者）</strong></td><td>从Broker接收消息的客户端（如服务器、APP）。</td></tr><tr><td><strong>Broker（代理服务器）</strong></td><td>负责接收消息、过滤Topic，并将消息转发给订阅者（如Mosquitto、EMQX）。</td></tr><tr><td><strong>Topic（主题）</strong></td><td>消息的分类标识符，采用层级结构（如<code>sensor/temperature</code>）。</td></tr></tbody></table><h3 id="2-1MQTT通信流程"><a href="#2-1MQTT通信流程" class="headerlink" title="2. 1MQTT通信流程"></a>2. 1MQTT通信流程</h3><p><strong>第一步： 建立连接</strong></p><ol><li>Publisher&#x2F;Subscriber通过TCP连接到Broker。  </li><li>Publisher发送<code>CONNECT</code>报文，携带客户端ID、认证信息等。  </li><li>Broker回复<code>CONNACK</code>确认连接。</li></ol><p><strong>第二步：订阅Topic</strong></p><ul><li>Subscriber向Broker发送<code>SUBSCRIBE</code>报文，指定要监听的Topic（支持通配符）：  <ul><li><code>/sensor/temperature</code>：精确匹配  </li><li><code>/sensor/#</code>：匹配所有子主题（<code>#</code>为多级通配符）  </li><li><code>/+/humidity</code>：匹配单级通配符（<code>+</code>为单级通配符）</li></ul></li></ul><p><strong>第三步：发布消息</strong></p><ul><li>Publisher向Broker发送<code>PUBLISH</code>报文，包含：  <ul><li>Topic名称（如<code>sensor/temperature</code>）  </li><li>Payload（实际数据，如<code>25.5℃</code>）  </li><li>QoS级别（0&#x2F;1&#x2F;2）</li></ul></li><li>Broker根据Topic匹配规则，将消息推送给所有订阅者。</li></ul><p><strong>第四步：断开连接</strong></p><ul><li>Publisher或Subscriber发送<code>DISCONNECT</code>报文主动断开连接。</li></ul><hr><h3 id="2-2-MQTT-vs-HTTP模型对比"><a href="#2-2-MQTT-vs-HTTP模型对比" class="headerlink" title="2.2. MQTT vs. HTTP模型对比"></a>2.2. MQTT vs. HTTP模型对比</h3><table><thead><tr><th><strong>特性</strong></th><th>MQTT（发布&#x2F;订阅）</th><th>HTTP（请求&#x2F;响应）</th></tr></thead><tbody><tr><td><strong>耦合性</strong></td><td>完全解耦</td><td>强耦合（客户端必须主动请求）</td></tr><tr><td><strong>实时性</strong></td><td>Broker主动推送消息，实时性高</td><td>需轮询或长连接，延迟较高</td></tr><tr><td><strong>适用场景</strong></td><td>IoT、即时通讯、高频小数据</td><td>Web页面、文件传输</td></tr><tr><td><strong>网络开销</strong></td><td>协议头极小（最小2字节）</td><td>HTTP头较大（通常几百字节）</td></tr></tbody></table><h2 id="3-MQTT控制报文格式"><a href="#3-MQTT控制报文格式" class="headerlink" title="3.MQTT控制报文格式"></a>3.MQTT控制报文格式</h2><p>报文格式组成：固定报头（Fixed Header） 、 可变报头（Variable Header） 和 有效载荷（Payload），一共三部分。</p><p><img src="/./IOT-Protocol-MQTT/image-20250524234700856.png" alt="image-20250524234700856"></p><h3 id="固定报头（Fixed-Header）"><a href="#固定报头（Fixed-Header）" class="headerlink" title="固定报头（Fixed Header）"></a>固定报头（Fixed Header）</h3><p>固定报头存在于所有MQTT报文中，是每个报文的必要部分，用于标识报文的类型及分组信息。<br>固定报头的格式如下：包括 标志位+报文类型+剩余长度</p><p><img src="/./IOT-Protocol-MQTT/image-20250524234937610.png" alt="image-20250524234937610"></p><p>报文类型：占用第一个字节的第4到7位，共4位，表示MQTT控制报文的类型</p><p><img src="/./IOT-Protocol-MQTT/image-20250524235118646.png" alt="image-20250524235118646"><br><img src="/./IOT-Protocol-MQTT/image-20250524235155671.png" alt="image-20250524235155671"></p><p>保留位（Reserved） ：占用第一个字节的第3到0位，共4位。通常保留为0，但在某些情况下可能用于特定功能</p><p><img src="/./IOT-Protocol-MQTT/image-20250524235505088.png" alt="image-20250524235505088"></p><p>​</p><p>剩余长度：占用第二个字节，表示固定报头和可变报头的总长度，也就是表示的在剩余长度之后的数据长度（还有多少个字节）。</p><p>​下面给大家讲一下计算的方法，这里需要说明一下，剩余长度的每一个字节的最高位是一个标志位，用来表示下一个字节是否也属于剩余长度，如果高位是1则表示下一个字节也是属于剩余长度，0则相反。<br>​计算长度的时候需要将每个字节的高位去掉，将高字节的</p><p>举个例子：这里剩余长度是第二个字节我就从第二个字节开始了</p><p>这里我们可以看到第三个字节是属于的，后面的字节就不是了，然后长度等于000 0001 010 0000&#x3D;160<br>懂了吧？很简单的，如果也有多字节，就以此类推。</p><table><thead><tr><th>第二个字节</th><th>第三个字节</th></tr></thead><tbody><tr><td>1010 0000</td><td>0000 0001</td></tr></tbody></table><h3 id="可变报头（Variable-Header）"><a href="#可变报头（Variable-Header）" class="headerlink" title="可变报头（Variable Header）"></a>可变报头（Variable Header）</h3><p>可变报头根据报文类型的不同而变化，存在于部分MQTT报文中。其主要作用是携带额外的信息，例如主题名称、消息ID、订阅过滤器等。<br>很多控制报文的可变报头部分包含一个两字节的报文标识符字段。这些报文是 PUBLISH（QoS&gt;0 时），PUBACK，PUBREC，PUBREL，PUBCOMP，SUBSCRIBE, SUBACK，UNSUBSCIBE，UNSUBACK。</p><p><img src="/./IOT-Protocol-MQTT/image-20250525002531884.png" alt="image-20250525002531884"></p><p><img src="/./IOT-Protocol-MQTT/image-20250525002604353.png" alt="image-20250525002604353"></p><p>例如：</p><ul><li>SUBSCRIBE报文：包含订阅的主题列表和相应的QoS等级。</li><li>PUBLISH报文：包含主题名称和消息内容。</li><li>CONNECT报文：包含客户端标识符和协议版本等信息。</li></ul><h3 id="有效载荷（Payload）"><a href="#有效载荷（Payload）" class="headerlink" title="有效载荷（Payload）"></a>有效载荷（Payload）</h3><p>有效载荷是MQTT报文的核心部分，用于存储实际的数据内容。</p><p>例如：</p><ul><li>SUBSCRIBE报文：包含订阅的主题列表和相应的QoS等级。</li><li>PUBLISH报文：包含实际的消息内容，例如文本数据、图像数据等。</li><li>DISCONNECT报文：包含断开连接的请求信息。</li></ul><p><img src="/./IOT-Protocol-MQTT/image-20250525002851878.png" alt="image-20250525002851878"></p><h2 id="实践抓包分析"><a href="#实践抓包分析" class="headerlink" title="实践抓包分析"></a>实践抓包分析</h2><h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><p>​首先我们需要下载一个[wireshark](<a href="https://www.wireshark.org/download.html">Wireshark · Download</a>)用于抓MQTT包,一定要下载新的版本的，我看别人说老版本有些不支持mqtt协议，需要额外下载相关的插件，我就下载的新的，多一事不如少一事。</p><p><img src="/./IOT-Protocol-MQTT/image-20250524230110030.png"></p><p>然后再下载一个[mqttx](<a href="https://www.emqx.com/zh/try?tab=more-products">免费试用 EMQX Cloud 或 EMQX Enterprise | 下载 EMQX</a>),一个全功能的开源 MQTT 客户端工具。</p><p><img src="/./IOT-Protocol-MQTT/image-20250524231857860.png" alt="image-20250524231857860"></p><p>下载好之后就可以建立个链接，名称随便起，默认的mqtt协议端口就是1883,就可以保存连接远端服务器了。</p><p><img src="/./IOT-Protocol-MQTT/image-20250524232032363.png" alt="image-20250524232032363"></p><p>对于wireshark的设置没什么了，因为我们是新版的所以就有些设置好了，捕获其记得用WLAN，因为我们要用主机与远端通信。</p><p><img src="/./IOT-Protocol-MQTT/image-20250524232417301.png" alt="image-20250524232417301"></p><p>然后就可以点击捕获，同时把mqttx打开连接就可以还发现捕获到了mqtt协议了。</p><p><img src="/./IOT-Protocol-MQTT/image-20250525003946280.png" alt="image-20250525003946280"></p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>我们可以看到红色框起来的是tcp建立连接的三次握手</p><p><img src="/./IOT-Protocol-MQTT/image-20250525004036181.png" alt="image-20250525004036181"></p><h4 id="Connect协议类型"><a href="#Connect协议类型" class="headerlink" title="Connect协议类型"></a>Connect协议类型</h4><p>我们往下看，看到了mqtt的连接请求，我们首先分析第一个固定报头中的数据类型，发现是16进制的10也就是0001 0000，类型是connect，我们去上面查找类型表，和状态表，发现是一样的。</p><p><img src="/./IOT-Protocol-MQTT/image-20250525010418783.png" alt="image-20250525010418783"><br><img src="/./IOT-Protocol-MQTT/image-20250525010444664.png" alt="image-20250525010444664"></p><p><img src="/./IOT-Protocol-MQTT/image-20250525005119469.png" alt="image-20250525005119469"><br><img src="/./IOT-Protocol-MQTT/image-20250525010052880.png" alt="image-20250525010052880"></p><p>msg len代表的是剩余长度，占一个字节</p><p><img src="/./IOT-Protocol-MQTT/image-20250525013000116.png" alt="image-20250525013000116"></p><p>下面是可变报文的内容：<br><img src="/./IOT-Protocol-MQTT/image-20250525014052924.png" alt="image-20250525014052924"></p><p>Connect报文的可变报头包含协议名，协议等级，连接标志和保持连接<br><img src="/./IOT-Protocol-MQTT/image-20250525013547391.png" alt="image-20250525013547391"></p><p>有效载荷：<br>CONNECT报文的有效载荷（payload）包含一个或多个以长度为前缀的字段，可变报头中的 标志决定是否包含这些字段。如果包含的话，必须按这个顺序出现：客户端标识符，遗嘱主题，遗嘱消息，用户名，密码。<br>客户端标识符(client identifier)：服务器通过识别客户标识符，确定客户端，识别两者间的MQTT会话相关状态，服务器允许客户端提供一个零字节的标识符，但clean session必须置1。</p><p><img src="/./IOT-Protocol-MQTT/image-20250525014228237.png" alt="image-20250525014228237"></p><p>哎，时间有限，就先写这么多吧，其他的类型可以以此类推，记得每个报文类型的可变报文和有效负载的内容不同，具体的要去查资料。<br>最好是查官方的MQTT协议介绍。</p>]]></content>
    
    
    
    <tags>
      
      <tag>protocol</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
